# Grafana Dashboard Filter Rules

## Persistent Rule: Filter Query Pattern

- All dashboard filters (templating variables) **must** query the SQLite server for their list of values.
- The SQL for each filter should use a `SELECT DISTINCT ... FROM ...` query, returning only the relevant values.
- When using a filter in a panel's SQL, always use the `${filter:sqlstring}` syntax in the WHERE clause to support multi-select and "All" options.
- This applies to all filters, including but not limited to: Org/Owner, Repo, Author, State, Merged, etc.

**Example:**
```json
{
  "name": "org",
  "type": "query",
  "datasource": "SQLite",
  "query": "SELECT DISTINCT substr(r.full_name, 1, instr(r.full_name, '/')-1) AS org FROM github_repos r ORDER BY org;",
  ...
}
```
And in the panel SQL:
```sql
WHERE substr(r.full_name, 1, instr(r.full_name, '/')-1) IN (${org:sqlstring})
```

**Rationale:**  
This ensures all filter values are always up-to-date with the database, and dashboards remain flexible and user-friendly.

_Last updated: 2025-11-08_

---

## Persistent Rule: Human-Friendly Visual Formatting

- All headers for visuals (panel titles, table column headers) and visual subitems (filter labels, legend items, etc.) **must always be nicely formatted for human users**.
  - Use capitalization and spacing appropriate for natural language.
  - Avoid code-style names (e.g., use "Open PRs" not "open_prs", "Repo" not "repo").
  - Ensure all visible labels are clear, concise, and user-friendly.

**Rationale:**  
This ensures dashboards are readable and approachable for all users, not just developers.

_Last updated: 2025-11-08_

---

## Persistent Rule: Visual Query/Legend/Transformation Consistency

- Whenever you update a panel's SQL query (especially changes to SELECT or GROUP BY clauses), you **must** review and update the panel's legend and transformation settings as needed, so the visual displays the intended breakdown and grouping (e.g., stacking by group, correct legend entries, etc.).
- Never assume the legend or transformations will "just work" after a query change—always check and adjust them to match the new query output.

**Rationale:**  
This ensures that changes to the data structure are always reflected in the way the chart is rendered and labeled, preventing mismatches between the data and the visual.

_Last updated: 2025-11-09_

---

## Note for SQLite

- Use SQLite-compatible SQL in all queries (e.g., use `substr(..., 1, instr(..., '/')-1)` instead of Postgres `split_part`).
- The `${filter:sqlstring}` syntax is supported by Grafana for multi-select variables with the frser-sqlite-datasource.
- All other rules apply as written.

---

## Persistent Rule: Dashboard and Panel Descriptions

- **All Grafana dashboards and all panels must include a clear, useful, and human-friendly description.**
  - The `description` field should summarize the purpose, key metrics, intended use, and—if applicable—how dashboard filters affect the data shown.
  - If the dashboard or panel uses filters (templating variables), the description should explain what each filter does and how it impacts the visual.
  - If a panel makes use of Data Links, the description should note the behavior of those links and, where suitable, provide an example use case.
  - Descriptions must be specific enough to help users and maintainers understand what each dashboard and panel is for, even out of context.
  - For long descriptions, use newlines to break up content for readability.
  - Avoid leaving the `description` field blank or using generic text or placeholder values (e.g., "No description", "TBD", etc.).

**Rationale:**  
Comprehensive descriptions improve usability, onboarding, and maintenance. They ensure that dashboards and panels are self-explanatory and reduce the risk of confusion or misinterpretation. Including filter explanations, Data Link behavior, and readable formatting further enhances clarity for all users.

_Last updated: 2025-11-10_

---

## Persistent Rule: Dashboard Tagging

- **All Grafana dashboards must use tags that are distinguishing and not universal.**
  - Do not use tags like "treasury" or "reporting", they could apply to all dashboards.
  - Tags should be concise, descriptive, and useful for filtering dashboards by function, data type, or business process.
  - Example tags: `breakdown`, `revenue`, `expenses`, `pnl`, `monthly`, `cashflow`, `operating`, `assets`, `balances`, `historical`, `unsorted`, `current`, `streams`, `llamapay`, `payments`, `transactions`, `detailed`.
  - When adding or editing a dashboard, review the current tags in use and select those that best describe the dashboard's unique purpose.
  - Update the documentation and tag mapping in `docs/dashboards.rst` if you introduce new tags.

**Rationale:**  
Consistent, non-universal tags make dashboards easier to filter, discover, and maintain. They help users quickly find the dashboards most relevant to their needs.

_Last updated: 2025-11-10_
